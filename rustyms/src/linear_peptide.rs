#![warn(dead_code)]

use std::{
    fmt::Display,
    marker::PhantomData,
    num::NonZeroU16,
    ops::{Index, RangeBounds},
    slice::SliceIndex,
};

use crate::{
    error::{Context, CustomError},
    fragment::{DiagnosticPosition, PeptidePosition},
    helper_functions::{end_of_enclosure, ResultExtensions},
    modification::{
        AmbiguousModification, GlobalModification, GnoComposition, ReturnModification,
        SimpleModification,
    },
    molecular_charge::MolecularCharge,
    peptide_complexity::*,
    placement_rule::{PlacementRule, Position},
    CompoundPeptidoform, DiagnosticIon, Element, MolecularFormula, Multi, MultiChemical,
    NeutralLoss, Protease, SequenceElement,
};
use itertools::Itertools;
use serde::{Deserialize, Serialize};
use uom::num_traits::Zero;

use crate::{
    fragment::Fragment, fragment::FragmentType, modification::Modification, system::usize::Charge,
    Chemical, Model,
};

/// A peptide with all data as provided by pro forma. Preferably generated by using the [`crate::ComplexPeptide::pro_forma`] function.
#[derive(Default, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Serialize, Deserialize, Hash)]
pub struct LinearPeptide<T> {
    /// Global isotope modifications, saved as the element and the species that
    /// all occurrence of that element will consist of. Eg (N, 15) will make
    /// all occurring nitrogens be isotope 15.
    global: Vec<(Element, Option<NonZeroU16>)>,
    /// Labile modifications, which will not be found in the actual spectrum.
    pub labile: Vec<SimpleModification>,
    /// N terminal modification
    pub n_term: Option<SimpleModification>,
    /// C terminal modification
    pub c_term: Option<SimpleModification>,
    /// The sequence of this peptide (includes local modifications)
    pub sequence: Vec<SequenceElement>,
    /// For each ambiguous modification list all possible positions it can be placed on.
    /// Indexed by the ambiguous modification id.
    pub ambiguous_modifications: Vec<Vec<usize>>,
    /// The adduct ions, if specified
    pub charge_carriers: Option<MolecularCharge>,
    /// The marker indicating which level of complexity this peptide (potentially) uses
    marker: PhantomData<T>,
}

/// Builder style methods to create a [`LinearPeptide`]
impl<T> LinearPeptide<T> {
    pub(crate) fn mark<M>(self) -> LinearPeptide<M> {
        LinearPeptide {
            global: self.global,
            labile: self.labile,
            n_term: self.n_term,
            c_term: self.c_term,
            sequence: self.sequence,
            ambiguous_modifications: self.ambiguous_modifications,
            charge_carriers: self.charge_carriers,
            marker: PhantomData,
        }
    }

    /// Create a new [`LinearPeptide`], if you want an empty peptide look at [`LinearPeptide::default`].
    /// Potentially the `.collect()` or `.into()` methods can be useful as well.
    #[must_use]
    pub fn new(sequence: impl IntoIterator<Item = SequenceElement>) -> Self {
        sequence.into_iter().collect()
    }

    /// Add global isotope modifications, if any is invalid it returns None
    #[must_use]
    pub fn global(
        mut self,
        global: impl IntoIterator<Item = (Element, Option<NonZeroU16>)>,
    ) -> Option<Self> {
        for modification in global {
            if modification.0.is_valid(modification.1) {
                self.global.push(modification);
            } else {
                return None;
            }
        }
        Some(self)
    }

    /// Add labile modifications
    #[must_use]
    pub fn labile(mut self, labile: impl IntoIterator<Item = SimpleModification>) -> Self {
        self.labile.extend(labile);
        self
    }

    /// Add the N terminal modification
    #[must_use]
    pub fn n_term(mut self, term: Option<SimpleModification>) -> Self {
        self.n_term = term;
        self
    }

    /// Add the C terminal modification
    #[must_use]
    pub fn c_term(mut self, term: Option<SimpleModification>) -> Self {
        self.c_term = term;
        self
    }

    /// Add the charge carriers
    #[must_use]
    pub fn charge_carriers(mut self, charge: Option<MolecularCharge>) -> Self {
        self.charge_carriers = charge;
        self
    }
}

impl<T> LinearPeptide<T> {
    /// Read sloppy pro forma like sequences. Defined by the use of square or round braces to indicate
    /// modifications and missing any particular method of defining the N or C terminal modifications.
    /// Additionally any underscores will be ignored both on the ends and inside the sequence.
    ///
    /// All modifications follow the same definitions as the strict pro forma syntax, if it cannot be
    /// parsed as a strict pro forma modification it falls back to [`Modification::sloppy_modification`].
    ///
    /// # Errors
    /// If it does not fit the above description.
    pub fn sloppy_pro_forma(
        line: &str,
        location: std::ops::Range<usize>,
    ) -> Result<LinearPeptide<VerySimple>, CustomError> {
        if line[location.clone()].trim().is_empty() {
            return Err(CustomError::error(
                "Peptide sequence is empty",
                "A peptide sequence cannot be empty",
                Context::line(0, line, location.start, 1),
            ));
        }
        let mut peptide = LinearPeptide::<VerySimple>::default();
        let mut ambiguous_lookup = Vec::new();
        let chars: &[u8] = line[location.clone()].as_bytes();
        let mut index = 0;

        while index < chars.len() {
            match chars[index] {
                b'_' => index += 1, //ignore
                b'[' | b'(' => {
                    let (open, close) = if chars[index] == b'[' {
                        (b'[', b']')
                    } else {
                        (b'(', b')')
                    };
                    let end_index =
                        end_of_enclosure(chars, index + 1, open, close).ok_or_else(|| {
                            CustomError::error(
                                "Invalid modification",
                                "No valid closing delimiter",
                                Context::line(0, line, location.start + index, 1),
                            )
                        })?;
                    let modification = Modification::try_from(
                        line,
                        location.start + index + 1..location.start + end_index,
                        &mut ambiguous_lookup,
                    )
                    .map(|m| {
                        m.defined().ok_or_else(|| {
                            CustomError::error(
                                "Invalid modification",
                                "A modification in the sloppy peptide format cannot be ambiguous",
                                Context::line(
                                    0,
                                    line,
                                    location.start + index + 1,
                                    end_index - 1 - index,
                                ),
                            )
                        })
                    })
                    .flat_err()
                    .map_err(|err| {
                        Modification::sloppy_modification(
                            line,
                            location.start + index + 1..location.start + end_index,
                            peptide.sequence.last(),
                        )
                        .ok_or(err)
                        .map(|m| Modification::Simple(m))
                    })
                    .flat_err()?;
                    index = end_index + 1;

                    match peptide.sequence.last_mut() {
                        Some(aa) => aa.modifications.push(modification),
                        None => {
                            peptide.n_term = Some(
                                modification
                                    .simple()
                                    .expect("Can only put a simple modification on an N terminus.")
                                    .clone(),
                            )
                        }
                    }
                }
                ch => {
                    peptide.sequence.push(SequenceElement::new(
                        ch.try_into().map_err(|()| {
                            CustomError::error(
                                "Invalid amino acid",
                                "This character is not a valid amino acid",
                                Context::line(0, line, location.start + index, 1),
                            )
                        })?,
                        None,
                    ));
                    index += 1;
                }
            }
        }
        peptide.enforce_modification_rules()?;
        Ok(peptide)
    }

    /// Get the number of amino acids making up this peptide
    pub fn len(&self) -> usize {
        self.sequence.len()
    }

    /// Check if there are any amino acids in this peptide
    pub fn is_empty(&self) -> bool {
        self.sequence.is_empty()
    }

    /// The mass of the N terminal modifications. The global isotope modifications are NOT applied.
    pub fn get_n_term(&self) -> MolecularFormula {
        self.n_term.as_ref().map_or_else(
            || molecular_formula!(H 1),
            |m| molecular_formula!(H 1) + m.formula(),
        )
    }

    /// The mass of the C terminal modifications. The global isotope modifications are NOT applied.
    pub fn get_c_term(&self) -> MolecularFormula {
        self.c_term.as_ref().map_or_else(
            || molecular_formula!(H 1 O 1),
            |m| molecular_formula!(H 1 O 1) + m.formula(),
        )
    }

    /// Get the global isotope modifications
    pub fn get_global(&self) -> &[(Element, Option<NonZeroU16>)] {
        &self.global
    }

    /// # Errors
    /// If a modification rule is broken it returns an error.
    pub(crate) fn enforce_modification_rules(&self) -> Result<(), CustomError> {
        for (position, seq) in self.iter(..) {
            seq.enforce_modification_rules(&position)?;
        }
        Ok(())
    }

    /// Find all neutral losses in the given stretch of peptide
    fn potential_neutral_losses(
        &self,
        range: impl RangeBounds<usize>,
    ) -> Vec<(NeutralLoss, PeptidePosition)> {
        self.iter(range)
            .flat_map(|(pos, aa)| {
                aa.modifications
                    .iter()
                    .filter_map(move |modification| {
                        if let Modification::Simple(SimpleModification::Predefined(
                            _,
                            rules,
                            _,
                            _,
                            _,
                        )) = modification
                        {
                            Some(rules)
                        } else {
                            None
                        }
                    })
                    .flatten()
                    .filter_map(move |(rules, rule_losses, _)| {
                        if PlacementRule::any_possible(rules, aa, &pos) {
                            Some(rule_losses)
                        } else {
                            None
                        }
                    })
                    .flatten()
                    .map(move |loss| (loss.clone(), pos))
            })
            .collect()
    }

    /// Find all diagnostic ions for this full peptide
    fn diagnostic_ions(&self) -> Vec<(DiagnosticIon, DiagnosticPosition)> {
        self.iter(..)
            .flat_map(|(pos, aa)| {
                aa.modifications
                    .iter()
                    .filter_map(move |modification| {
                        if let Modification::Simple(SimpleModification::Predefined(
                            _,
                            rules,
                            _,
                            _,
                            _,
                        )) = modification
                        {
                            Some(rules)
                        } else {
                            None
                        }
                    })
                    .flatten()
                    .filter_map(move |(rules, _, rule_diagnostic)| {
                        if PlacementRule::any_possible(rules, aa, &pos) {
                            Some(rule_diagnostic)
                        } else {
                            None
                        }
                    })
                    .flatten()
                    .map(move |loss| (loss.clone(), DiagnosticPosition::Peptide(pos, aa.aminoacid)))
            })
            .chain(
                self.labile
                    .iter()
                    .filter_map(move |modification| {
                        if let SimpleModification::Predefined(_, rules, _, _, _) = modification {
                            Some((rules, modification))
                        } else {
                            None
                        }
                    })
                    .flat_map(|(rules, labile)| {
                        rules.iter().flat_map(|(_, _, diag)| diag).map(|diag| {
                            (
                                diag.clone(),
                                DiagnosticPosition::Labile(labile.clone().into()),
                            )
                        })
                    }),
            )
            .collect()
    }

    /// Iterate over a range in the peptide and keep track of the position
    fn iter(
        &self,
        range: impl RangeBounds<usize>,
    ) -> impl DoubleEndedIterator<Item = (PeptidePosition, &SequenceElement)> + '_ {
        let start = match range.start_bound() {
            std::ops::Bound::Unbounded => 0,
            std::ops::Bound::Included(i) => (*i).max(0),
            std::ops::Bound::Excluded(ex) => (ex + 1).max(0),
        };
        self.sequence[(range.start_bound().cloned(), range.end_bound().cloned())]
            .iter()
            .enumerate()
            .map(move |(index, seq)| (PeptidePosition::n(index + start, self.len()), seq))
    }

    /// Apply a global modification if this is a global isotope modification with invalid isotopes it returns false
    #[must_use]
    pub(crate) fn apply_global_modifications(
        &mut self,
        global_modifications: &[GlobalModification],
    ) -> bool {
        let length = self.len();
        for modification in global_modifications {
            match modification {
                GlobalModification::Fixed(pos, aa, modification) => {
                    for (_, seq) in self.sequence.iter_mut().enumerate().filter(|(index, seq)| {
                        pos.is_possible(&PeptidePosition::n(*index, length))
                            && aa.map_or(true, |aa| aa == seq.aminoacid)
                            && modification.is_possible(seq, &PeptidePosition::n(*index, length))
                    }) {
                        match pos {
                            Position::Anywhere => seq.modifications.push(modification.clone()),
                            Position::AnyNTerm | Position::ProteinNTerm => {
                                self.n_term = Some(
                                    modification
                                        .simple()
                                        .expect(
                                            "Can only put a simple modification on an N terminus",
                                        )
                                        .clone(),
                                );
                            }
                            Position::AnyCTerm | Position::ProteinCTerm => {
                                self.c_term = Some(
                                    modification
                                        .simple()
                                        .expect(
                                            "Can only put a simple modification on a C terminus",
                                        )
                                        .clone(),
                                );
                            }
                        }
                    }
                }
                GlobalModification::Isotope(el, isotope) if el.is_valid(*isotope) => {
                    self.global.push((*el, *isotope));
                }
                GlobalModification::Isotope(..) => return false,
            }
        }
        true
    }

    /// Place all global unknown positions at all possible locations as ambiguous modifications
    pub(crate) fn apply_unknown_position_modification(
        &mut self,
        unknown_position_modifications: &[Modification],
    ) {
        for modification in unknown_position_modifications {
            let id = self.ambiguous_modifications.len();
            let length = self.len();
            #[allow(clippy::unnecessary_filter_map)]
            // Side effects so the lint does not apply here
            self.ambiguous_modifications.push(
                (0..length)
                    .filter_map(|i| {
                        if modification
                            .is_possible(&self.sequence[i], &PeptidePosition::n(i, length))
                        {
                            self.sequence[i]
                                .possible_modifications
                                .push(AmbiguousModification {
                                    id,
                                    modification: modification.clone(),
                                    localisation_score: None,
                                    group: None,
                                });
                            Some(i)
                        } else {
                            None
                        }
                    })
                    .collect(),
            );
        }
    }
    /// Place all ranged unknown positions at all possible locations as ambiguous modifications
    /// # Panics
    /// It panics when information for an ambiguous modification is missing (name/mod).
    pub(crate) fn apply_ranged_unknown_position_modification(
        &mut self,
        ranged_unknown_position_modifications: &[(usize, usize, ReturnModification)],
        ambiguous_lookup: &[(Option<String>, Option<Modification>)],
    ) {
        for (start, end, ret_modification) in ranged_unknown_position_modifications {
            let (id, modification, score, group) = match ret_modification {
                ReturnModification::Defined(def) => {
                    self.ambiguous_modifications.push(Vec::new());
                    (
                        self.ambiguous_modifications.len() - 1,
                        def.clone(),
                        None,
                        None,
                    )
                }
                ReturnModification::Preferred(i, score) => {
                    if *i >= self.ambiguous_modifications.len() {
                        self.ambiguous_modifications.push(Vec::new());
                    }
                    (
                        *i,
                        ambiguous_lookup[*i].1.clone().unwrap(),
                        *score,
                        Some((ambiguous_lookup[*i].0.clone().unwrap(), true)), // TODO: now all possible location in the range are listed as preferred
                    )
                }
                ReturnModification::Referenced(i, score) => {
                    if *i >= self.ambiguous_modifications.len() {
                        self.ambiguous_modifications.push(Vec::new());
                    }
                    (
                        *i,
                        ambiguous_lookup[*i].1.clone().unwrap(),
                        *score,
                        Some((ambiguous_lookup[*i].0.clone().unwrap(), false)),
                    )
                }
            };
            let length = self.len();
            #[allow(clippy::unnecessary_filter_map)]
            // Side effects so the lint does not apply here
            let positions = (*start..=*end)
                .filter_map(|i| {
                    if modification.is_possible(&self.sequence[i], &PeptidePosition::n(i, length)) {
                        self.sequence[i]
                            .possible_modifications
                            .push(AmbiguousModification {
                                id,
                                modification: modification.clone(),
                                localisation_score: None,
                                group: group.clone(),
                            });
                        Some(i)
                    } else {
                        None
                    }
                })
                .collect_vec();
            if let Some(score) = score {
                let individual_score = score / positions.len() as f64;
                for pos in &positions {
                    self.sequence[*pos]
                        .possible_modifications
                        .last_mut()
                        .unwrap()
                        .localisation_score = Some(individual_score);
                }
            }
            self.ambiguous_modifications[id].extend(positions);
        }
    }

    /// Generate all possible patterns for the ambiguous positions (Mass, String:Label).
    /// It always contains at least one pattern (being (base mass, "")).
    /// The global isotope modifications are NOT applied.
    fn ambiguous_patterns(
        &self,
        range: impl RangeBounds<usize>,
        aa_range: impl RangeBounds<usize>,
        index: usize,
        base: MolecularFormula,
        all_peptides: &[LinearPeptide<Linked>],
        visited_peptides: &[usize],
    ) -> Multi<MolecularFormula> {
        let result = self
            .ambiguous_modifications
            .iter()
            .enumerate()
            .fold(vec![Vec::new()], |acc, (id, possibilities)| {
                acc.into_iter()
                    .flat_map(|path| {
                        let mut path_clone = path.clone();
                        let options = possibilities.iter().filter(|pos| range.contains(pos)).map(
                            move |pos| {
                                let mut new = path.clone();
                                new.push((id, *pos));
                                new
                            },
                        );
                        options.chain(possibilities.iter().find(|pos| !range.contains(pos)).map(
                            move |pos| {
                                path_clone.push((id, *pos));
                                path_clone
                            },
                        ))
                    })
                    .collect()
            })
            .into_iter()
            .flat_map(|pattern| {
                let ambiguous_local = pattern
                    .iter()
                    .filter_map(|(id, pos)| (*pos == index).then_some(id))
                    .collect::<Vec<_>>();
                self.sequence[(
                    aa_range.start_bound().cloned(),
                    aa_range.end_bound().cloned(),
                )]
                    .iter()
                    .enumerate()
                    .fold(Multi::default(), |acc, (index, aa)| {
                        acc * aa.formulas(
                            &pattern
                                .clone()
                                .iter()
                                .copied()
                                .filter_map(|(id, pos)| (pos == index).then_some(id))
                                .collect_vec(),
                            all_peptides,
                            visited_peptides,
                        )
                    })
                    .iter()
                    .map(|m| {
                        self.sequence[index]
                            .possible_modifications
                            .iter()
                            .filter(|&am| ambiguous_local.contains(&&am.id))
                            .map(|am| am.modification.formula(all_peptides, visited_peptides))
                            .sum::<Multi<MolecularFormula>>()
                            + base
                            + m
                    })
                    .flat_map(|m| m.to_vec())
                    .collect_vec()
            })
            .collect::<Multi<MolecularFormula>>();
        if result.is_empty() {
            base.into()
        } else {
            result
        }
    }

    /// Generate the theoretical fragments for this peptide, with the given maximal charge of the fragments, and the given model.
    /// With the global isotope modifications applied.
    #[allow(clippy::missing_panics_doc)] // Invariants are uphold upon creation
    pub(crate) fn generate_theoretical_fragments_inner(
        &self,
        max_charge: Charge,
        model: &Model,
        peptide_index: usize,
        all_peptides: &[LinearPeptide<Linked>],
        visited_peptides: &[usize],
    ) -> Vec<Fragment> {
        let default_charge = MolecularCharge::proton(max_charge.value as isize);
        let charge_carriers = self.charge_carriers.as_ref().unwrap_or(&default_charge);
        let single_charges = charge_carriers.all_single_charge_options();

        let mut output = Vec::with_capacity(20 * self.sequence.len() + 75); // Empirically derived required size of the buffer (Derived from Hecklib)
        for index in 0..self.sequence.len() {
            let position = PeptidePosition::n(index, self.len());
            let n_term = self.all_masses(
                ..=index,
                ..index,
                index,
                self.get_n_term(),
                model.modification_specific_neutral_losses,
                all_peptides,
                visited_peptides,
            );
            let c_term = self.all_masses(
                index..,
                index + 1..,
                index,
                self.get_c_term(),
                model.modification_specific_neutral_losses,
                all_peptides,
                visited_peptides,
            );
            let modifications_total = self.sequence[index]
                .modifications
                .iter()
                .map(|m| m.formula(all_peptides, visited_peptides))
                .sum::<Multi<MolecularFormula>>();

            output.append(&mut self.sequence[index].aminoacid.fragments(
                &n_term,
                &c_term,
                &modifications_total,
                charge_carriers,
                index,
                self.sequence.len(),
                &model.ions(position),
                peptide_index,
            ));

            if model.m {
                // m fragment: precursor amino acid side chain losses
                output.extend(
                    self.formulas_inner(peptide_index, all_peptides, visited_peptides)
                        .iter()
                        .flat_map(|m| {
                            self.sequence[index]
                                .aminoacid
                                .formulas()
                                .iter()
                                .flat_map(|aa| {
                                    Fragment::generate_all(
                                        &((-modifications_total.clone()) + m.clone() - aa.clone()
                                            + molecular_formula!(C 2 H 2 N 1 O 1)),
                                        peptide_index,
                                        &FragmentType::m(position, self.sequence[index].aminoacid),
                                        &Multi::default(),
                                        &[],
                                    )
                                })
                                .map(|f| f.with_charge(charge_carriers))
                                .collect_vec()
                        }),
                );
            }
        }
        for fragment in &mut output {
            fragment.formula = fragment
                .formula
                .with_global_isotope_modifications(&self.global)
                .expect("Invalid global isotope modification");
        }

        // Generate precursor peak
        output.extend(
            self.formulas_inner(peptide_index, all_peptides, visited_peptides)
                .iter()
                .flat_map(|m| {
                    Fragment::new(
                        m.clone(),
                        Charge::zero(),
                        peptide_index,
                        FragmentType::precursor,
                        String::new(),
                    )
                    .with_charge(charge_carriers)
                    .with_neutral_losses(&model.precursor)
                }),
        );

        // Add glycan fragmentation to all peptide fragments
        // Assuming that only one glycan can ever fragment at the same time,
        // and that no peptide fragmentation occurs during glycan fragmentation
        for (sequence_index, position) in self.sequence.iter().enumerate() {
            for modification in &position.modifications {
                if let Modification::Simple(SimpleModification::GlycanStructure(glycan)) =
                    modification
                {
                    output.extend(
                        glycan
                            .clone()
                            .determine_positions()
                            .generate_theoretical_fragments(
                                model,
                                peptide_index,
                                charge_carriers,
                                &self.formulas_inner(peptide_index, all_peptides, visited_peptides),
                                (position.aminoacid, sequence_index),
                            ),
                    );
                } else if let Modification::Simple(SimpleModification::Gno(
                    GnoComposition::Structure(glycan),
                    _,
                )) = modification
                {
                    output.extend(
                        glycan
                            .clone()
                            .determine_positions()
                            .generate_theoretical_fragments(
                                model,
                                peptide_index,
                                charge_carriers,
                                &self.formulas_inner(peptide_index, all_peptides, visited_peptides),
                                (position.aminoacid, sequence_index),
                            ),
                    );
                }
            }
        }

        if model.modification_specific_diagnostic_ions {
            // Add all modification diagnostic ions
            output.extend(self.diagnostic_ions().into_iter().flat_map(|(dia, pos)| {
                Fragment {
                    formula: dia.0,
                    charge: Charge::default(),
                    ion: FragmentType::diagnostic(pos),
                    peptide_index,
                    neutral_loss: None,
                    label: String::new(),
                }
                .with_charges(&single_charges)
            }));
        }

        output
    }

    /// Generate all potential masses for the given stretch of amino acids.
    /// Applies ambiguous aminoacids and modifications, and neutral losses (if allowed in the model).
    fn all_masses(
        &self,
        range: impl RangeBounds<usize> + Clone,
        aa_range: impl RangeBounds<usize>,
        index: usize,
        base: MolecularFormula,
        apply_neutral_losses: bool,
        all_peptides: &[LinearPeptide<Linked>],
        visited_peptides: &[usize],
    ) -> Multi<MolecularFormula> {
        let ambiguous_mods_masses = self.ambiguous_patterns(
            range.clone(),
            aa_range,
            index,
            base,
            all_peptides,
            visited_peptides,
        );
        if apply_neutral_losses {
            let neutral_losses = self.potential_neutral_losses(range);
            let mut all_masses =
                Vec::with_capacity(ambiguous_mods_masses.len() * (1 + neutral_losses.len()));
            all_masses.extend(ambiguous_mods_masses.iter().cloned());
            for loss in &neutral_losses {
                all_masses.extend((ambiguous_mods_masses + loss.0).to_vec());
            }
            all_masses.into()
        } else {
            ambiguous_mods_masses
        }
    }

    /// Gives all the formulas for the whole peptide with no C and N terminal modifications. With the global isotope modifications applied.
    #[allow(clippy::missing_panics_doc)] // global isotope mods are guaranteed to be correct
    fn bare_formulas_inner(
        &self,
        all_peptides: &[LinearPeptide<Linked>],
        visited_peptides: &[usize],
    ) -> Multi<MolecularFormula> {
        let mut formulas = Multi::default();
        let mut placed = vec![false; self.ambiguous_modifications.len()];
        for pos in &self.sequence {
            formulas *= pos.formulas_greedy(&mut placed, all_peptides, visited_peptides);
        }

        formulas
            .iter()
            .map(|f| {
                f.with_global_isotope_modifications(&self.global)
                    .expect("Invalid global isotope modification in bare_formulas")
            })
            .collect()
    }

    /// Gives the formulas for the whole peptide. With the global isotope modifications applied. (Any B/Z will result in multiple possible formulas.)
    pub(crate) fn formulas_inner(
        &self,
        peptide_index: usize,
        all_peptides: &[LinearPeptide<Linked>],
        visited_peptides: &[usize],
    ) -> Multi<MolecularFormula> {
        let mut new_visited_peptides = vec![peptide_index];
        new_visited_peptides.extend_from_slice(&visited_peptides);
        let mut formulas: Multi<MolecularFormula> =
            vec![self.get_n_term() + self.get_c_term()].into();
        let mut placed = vec![false; self.ambiguous_modifications.len()];
        for pos in &self.sequence {
            formulas *= pos.formulas_greedy(&mut placed, all_peptides, &new_visited_peptides);
        }

        formulas
            .iter()
            .map(|f| f.with_global_isotope_modifications(&self.global).expect("Global isotope modification invalid in determination of all formulas for a peptide"))
            .collect()
    }
}

impl<T: Clone> LinearPeptide<T> {
    /// Get the reverse of this peptide
    #[must_use]
    pub fn reverse(&self) -> Self {
        Self {
            n_term: self.c_term.clone(),
            c_term: self.n_term.clone(),
            sequence: self.sequence.clone().into_iter().rev().collect(),
            ambiguous_modifications: self
                .ambiguous_modifications
                .clone()
                .into_iter()
                .map(|m| m.into_iter().map(|loc| self.len() - loc).collect())
                .collect(),
            ..self.clone()
        }
    }

    /// Get a region of this peptide as a new peptide (with all terminal/global/ambiguous modifications).
    #[must_use]
    pub fn sub_peptide(&self, index: impl RangeBounds<usize>) -> Self {
        Self {
            n_term: if index.contains(&0) {
                self.n_term.clone()
            } else {
                None
            },
            c_term: if index.contains(&(self.len() - 1)) {
                self.c_term.clone()
            } else {
                None
            },
            sequence: self.sequence[(index.start_bound().cloned(), index.end_bound().cloned())]
                .to_vec(),
            ..self.clone()
        }
    }

    /// Digest this sequence with the given protease and the given maximal number of missed cleavages.
    pub fn digest(&self, protease: &Protease, max_missed_cleavages: usize) -> Vec<Self> {
        let mut sites = vec![0];
        sites.extend_from_slice(&protease.match_locations(&self.sequence));
        sites.push(self.len());

        let mut result = Vec::new();

        for (index, start) in sites.iter().enumerate() {
            for end in sites.iter().skip(index).take(max_missed_cleavages + 1) {
                result.push(self.sub_peptide((*start)..*end));
            }
        }
        result
    }
}

impl LinearPeptide<Linked> {
    /// Convenience wrapper to parse a linear peptide in pro forma notation, to handle all possible pro forma sequences look at [`ComplexPeptide::pro_forma`].
    /// # Errors
    /// It gives an error when the peptide is not correctly formatted. (Also see the `ComplexPeptide` main function for this.)
    /// It additionally gives an error if the peptide specified was chimeric (see [`ComplexPeptide::singular`]).
    pub fn pro_forma(value: &str) -> Result<LinearPeptide<Linked>, CustomError> {
        let complex = CompoundPeptidoform::pro_forma(value)?;
        complex.singular().ok_or_else(|| {
            CustomError::error(
                "Complex peptide found",
                "A linear peptide was expected but a chimeric peptide was found.",
                crate::error::Context::Show {
                    line: value.to_string(),
                },
            )
        })
    }

    /// Gives the formulas for the whole peptide. With the global isotope modifications applied. (Any B/Z will result in multiple possible formulas.)
    pub(crate) fn formulas(
        &self,
        peptide_index: usize,
        all_peptides: &[LinearPeptide<Linked>],
        visited_peptides: &[usize],
    ) -> Multi<MolecularFormula> {
        self.formulas_inner(peptide_index, all_peptides, visited_peptides)
    }

    /// Gives all the formulas for the whole peptide with no C and N terminal modifications. With the global isotope modifications applied.
    #[allow(clippy::missing_panics_doc)] // global isotope mods are guaranteed to be correct
    pub fn bare_formulas(
        &self,
        all_peptides: &[LinearPeptide<Linked>],
        visited_peptides: &[usize],
    ) -> Multi<MolecularFormula> {
        self.bare_formulas_inner(all_peptides, visited_peptides)
    }
}

impl<T: Into<Linear>> LinearPeptide<T> {
    /// Gives the formulas for the whole peptide. With the global isotope modifications applied. (Any B/Z will result in multiple possible formulas.)
    pub(crate) fn formulas(&self) -> Multi<MolecularFormula> {
        let mut formulas: Multi<MolecularFormula> =
            vec![self.get_n_term() + self.get_c_term()].into();
        let mut placed = vec![false; self.ambiguous_modifications.len()];
        for pos in &self.sequence {
            formulas *= pos.formulas_greedy(&mut placed, &[], &[]);
        }

        formulas
            .iter()
            .map(|f| f.with_global_isotope_modifications(&self.global).expect("Global isotope modification invalid in determination of all formulas for a peptide"))
            .collect()
    }

    /// Gives all the formulas for the whole peptide with no C and N terminal modifications. With the global isotope modifications applied.
    pub fn bare_formulas(&self) -> Multi<MolecularFormula> {
        self.bare_formulas_inner(&[], &[])
    }

    /// Generate the theoretical fragments for this peptide, with the given maximal charge of the fragments, and the given model.
    /// With the global isotope modifications applied.
    ///
    /// # Panics
    /// If `max_charge` outside the range `1..=u64::MAX`.
    pub fn generate_theoretical_fragments(
        &self,
        max_charge: Charge,
        model: &Model,
    ) -> Vec<Fragment> {
        self.generate_theoretical_fragments_inner(max_charge, model, 0, &[], &[])
    }
}

impl<T> Display for LinearPeptide<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        for (element, isotope) in &self.global {
            write!(
                f,
                "<{}{}>",
                isotope.map(|i| i.to_string()).unwrap_or_default(),
                element
            )?;
        }
        for labile in &self.labile {
            write!(f, "{{{labile}}}")?;
        }
        if let Some(m) = &self.n_term {
            write!(f, "[{m}]-")?;
        }
        let mut placed = Vec::new();
        let mut last_ambiguous = None;
        for position in &self.sequence {
            placed.extend(position.display(f, &placed, last_ambiguous)?);
            last_ambiguous = position.ambiguous;
        }
        if last_ambiguous.is_some() {
            // TODO: Does not display ambiguous correctly
            write!(f, ")")?;
        }
        if let Some(m) = &self.c_term {
            write!(f, "-[{m}]")?;
        }
        if let Some(c) = &self.charge_carriers {
            write!(f, "/{c}")?;
        }
        Ok(())
    }
}

impl<Collection, Item, T> From<Collection> for LinearPeptide<T>
where
    Collection: IntoIterator<Item = Item>,
    Item: Into<SequenceElement>,
{
    fn from(value: Collection) -> Self {
        Self {
            global: Vec::new(),
            labile: Vec::new(),
            n_term: None,
            c_term: None,
            sequence: value.into_iter().map(std::convert::Into::into).collect(),
            ambiguous_modifications: Vec::new(),
            charge_carriers: None,
            marker: PhantomData,
        }
    }
}

impl<Item, T> FromIterator<Item> for LinearPeptide<T>
where
    Item: Into<SequenceElement>,
{
    fn from_iter<Iter: IntoIterator<Item = Item>>(iter: Iter) -> Self {
        Self::from(iter)
    }
}

impl<I: SliceIndex<[SequenceElement]>, T> Index<I> for LinearPeptide<T> {
    type Output = I::Output;

    fn index(&self, index: I) -> &Self::Output {
        &self.sequence[index]
    }
}

/// Make sure that any lower level of peptide can be cast to a higher level
macro_rules! into {
    ($a:tt => $b:ty) => {
        impl From<LinearPeptide<$a>> for LinearPeptide<$b>
        where
            $a: Into<$b>,
        {
            fn from(other: LinearPeptide<$a>) -> Self {
                other.mark()
            }
        }
    };
}

into!(Linear => Linked);
into!(Simple => Linked);
into!(VerySimple => Linked);
into!(ExtremelySimple => Linked);
into!(Simple => Linear);
into!(VerySimple => Linear);
into!(ExtremelySimple => Linear);
into!(VerySimple => Simple);
into!(ExtremelySimple => Simple);
into!(ExtremelySimple => VerySimple);
